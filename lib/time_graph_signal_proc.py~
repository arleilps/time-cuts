import networkx
import math
import scipy.optimize
import numpy
import sys
from scipy import sparse

from lib.vis import *
from lib.time_graph import *
from scipy import linalg
from numpy.linalg import eigh

def graph_fourier_transform(G, F, k):
	lambdas = []
	L = create_laplacian_matrix(G)
	
	try:
		(eigvals, eigvecs) = scipy.sparse.linalg.eigsh(L, k=k, which='SA')
	except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
		try:
			(eigvals, eigvecs) = scipy.sparse.linalg.eigs(L, k=k, which='SM')
		except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
			L = L.todense()
			(eigvals, eigvecs) = scipy.linalg.eigh(L, eigvals=(0, k))

	for i in range(0, k):
		lambdas.append(numpy.dot(F, eigvecs[:,i]))
	
	return numpy.array(lambdas), eigvecs

def graph_fourier_inverse(G, lambdas, eigvecs):
	k = lambdas.shape[0]

	F = numpy.zeros(G.number_of_nodes())

	for i in range(0, k):
		for v in range(G.number_of_nodes()):
			F[v] = F[v] + (lambdas[i] * eigvecs[v,i]).real
	
	return F

def create_signal_matrix(G, F, order=-1):
	row = []
	column = []
	value = []

	for t in range(G.num_snaps()):
		for k in range(G.num_snaps()):
			if order < 0 or numpy.absolute(t-k) <= order:
				for v in range(G.size()):
					for u in range(G.size()):
						(vi, ti) = G.rev_index_pos(G.size()*t + v)
						(vj, tj) = G.rev_index_pos(G.size()*k + u)
						
						if G.active(vi, t) and G.active(vj, k):
							row.append(G.size()*t + v)
							column.append(G.size()*k + u)
							value.append(math.pow(F[G.size()*t + v]-F[G.size()*k + u], 2))

	sz = G.num_snaps() * G.size()
	S = scipy.sparse.csr_matrix((value, (row, column)), shape=(sz, sz), dtype=float)

	return S

def sweep_signal(G, x, F, alpha):
	best_score = -sys.float_info.max
	sorted_x = numpy.argsort(x)
	edges_cut = 0
	swaps = 0
	nodes_one = []
	sizes_one = []
	sums_one = []
	sums_total = []
	den = 0

	for t in range(G.num_snaps()):
		nodes_one.append({})
		sizes_one.append(0)
		sums_one.append(0)
		sums_total.append(numpy.sum(F[G.size()*t:G.size()*t+G.size()]))

	for i in range(x.shape[0]-1):
		(v,t) = G.rev_index_pos(sorted_x[i])
		if G.active(v, t):
			den = den - sizes_one[t] * (G.number_of_nodes(t) - sizes_one[t])
			sizes_one[t] = sizes_one[t] + 1
			sums_one[t] = sums_one[t] + F[sorted_x[i]]
			den = den + sizes_one[t] * (G.number_of_nodes(t) - sizes_one[t])

			nodes_one[t][v] = True
			
			for u in G.graphs[t].neighbors(v):
				if u not in nodes_one[t]:
					edges_cut = edges_cut + G.graphs[t].edge[v][u]["weight"]
				else:
					edges_cut = edges_cut - G.graphs[t].edge[v][u]["weight"]

			if t+1 < G.num_snaps():
				if v not in nodes_one[t+1]:
					swaps = swaps + G.swap_cost_vertex(v, t)
				else:
					swaps = swaps - G.swap_cost_vertex(v, t)

			if t > 0:
				if v not in nodes_one[t-1]:
					swaps = swaps + G.swap_cost_vertex(v, t-1)
				else:
					swaps = swaps - G.swap_cost_vertex(v, t-1)

			den_reg = den + alpha * (swaps + edges_cut)
	
			num = 0.
			for t in range(G.num_snaps()):
				at = sizes_one[t] * (sums_total[t]-sums_one[t]) - (G.size()-sizes_one[t]) * sums_one[t]
				num = num + math.pow(at, 2) 
				
				for k in range(G.num_snaps()):
					if k != t:
						ak = sizes_one[k] * (sums_total[k]-sums_one[k]) - (G.size()-sizes_one[k]) * sums_one[k]
						num = num + at * ak

			if den_reg > 0:
				score = num / den_reg  
			else:
				score = -sys.float_info.max


			if score >= best_score:
				best_score = score
				best = i
				best_edges_cut = edges_cut
				best_swaps = swaps

	vec = numpy.zeros(G.size() * G.num_snaps())

	for i in range(x.shape[0]):
		(v,t) = G.rev_index_pos(sorted_x[i])
		
		if G.active(v,t):
			if i <= best:
				vec[sorted_x[i]] = -1.
			else:
				vec[sorted_x[i]] = 1.
		else:
			vec[sorted_x[i]] = 0.

	return {"cut": vec, "score": best_score, "edges": best_edges_cut, "swaps": best_swaps}

def evaluate_multi_cut_signal(G, F, part, assign, alpha):
	ratio = 0.
	
	sums_total = []
	for t in range(G.num_snaps()):
		sums_total.append(numpy.sum(F[G.size()*t:G.size()*t+G.size()]))


	for p in range(len(part)):
		cut = 0.
		swap = 0.
		den = 0.
		num = 0.

		for t in range(G.num_snaps()):
			for e in G.snap(t).edges():
				v1 = e[0]
				v2 = e[1]
				i1 = G.index_vertex(t,v1)
				i2 = G.index_vertex(t,v2)
			
				if (assign[i1] == p and assign[i2] != p) or (assign[i2] == p and assign[i1] != p):
					cut = cut + G.snap(t)[v1][v2]["weight"]

			if t < G.num_snaps() - 1:
				for v in G.nodes():
					i1 = G.index_vertex(t,v)
					i2 = G.index_vertex(t+1,v)

					if (assign[i1] == p and assign[i2] != p) or (assign[i2] == p and assign[i1] != p):
						swap = swap + G.swap_cost_vertex(v,t)
			
			size = 0.
			sum_values = 0.
			for v in G.nodes():
				i1 = G.index_vertex(t,v)

				if assign[i1] == p:
					size =  size + 1.
					sum_values  = sum_values + F[i1]
				
			
			at = size * (sums_total[t]-sum_values) - (G.size()-size) * sum_values
			num = num + math.pow(at, 2)
			den = den +  (G.size()-size) * size

			for k in range(G.num_snaps()):
				if k != t:
					size = 0.
					sum_values = 0.
					for v in G.nodes():
						i1 = G.index_vertex(t,v)

						if assign[i1] == p:
							size =  size + 1.
							sum_values  = sum_values + F[i1]
					
					ak = size * (sums_total[k]-sum_values) - (G.size()-size) * sum_values
					num = num + at * ak

		ratio = ratio + float(num) / (den + alpha * (swap + cut))

	return ratio

def wavelet_cut(G, F, alpha=1., order=-1)
	L = create_laplacian_matrix(G)
	C = create_c_matrix(G)
	S = create_signal_matrix(G, F, order)
	
	CSC = scipy.sparse.csr_matrix.dot(scipy.sparse.csr_matrix.dot(C, S), C)
	isqrtCL = sqrtmi( (C+alpha * L).todense())
	M = numpy.dot(numpy.dot(isqrtCL, CSC.todense()), isqrtCL)
	
	try:
		(eigvals, eigvecs) = scipy.sparse.linalg.eigsh(M, k=1)
		vec = eigvecs[:,0]
	except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
		try:
			(eigvals, eigvecs) = scipy.sparse.linalg.eigs(M, k=1)
			vec = eigvecs[:,0]
		except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
			M = M.todense()
			(eigvals, eigvecs) = scipy.linalg.eigh(M, eigvals=(0,0))
			vec = eigvecs[:,0]

	return sweep_signal(G, vec, F, alpha)

def multi_cut_signal(G, K, F, alpha):
	G.index_vertex()
	root = Node(None)
	k = 1
	cand_cuts = []
	cut = wavelet_cut(G, F, alpha, order)
	cut["parent"] = root
	cut["graph"] = G

	cand_cuts.append(cut)
	
	while k < K and len(cand_cuts) > 0:
		best_cut = None
		b = 0
		for c in range(len(cand_cuts)):
			if best_cut is None or cand_cuts[c]["score"] > best_cut["score"]:
				best_cut = cand_cuts[c]
				b = c

		(G1,G2) = best_cut["graph"].break_graph_cut(best_cut["cut"])
		
		if G1.number_of_nodes() == 1:
			(v, t) = G1.active_nodes()[0]
			i = G.index_vertex(t, v)
			n = Node([i])
			best_cut["parent"].add_child(n)
		else:
			n = Node(None)
			cut = wavelet_cut(G1, F, alpha, order)
			cut["parent"] = n
			cut["graph"] = G1
			
			cand_cuts.append(cut)
			best_cut["parent"].add_child(n)
		
		if G2.number_of_nodes() == 1:
			(v, t) = G2.active_nodes()[0]
			i = G.index_vertex(t, v)
			n = Node([i])
			best_cut["parent"].add_child(n)
		else:
			n = Node(None)
			cut = wavelet_cut(G2, F, alpha, order)
			cut["parent"] = n
			cut["graph"] = G2
			
			cand_cuts.append(cut)
			best_cut["parent"].add_child(n)

		del cand_cuts[b]
		
		k = k + 1

	for c in cand_cuts:
		parent = c["parent"]
		data = []
		for (v,t) in c["graph"].active_nodes():
			i = G.index_vertex(t, v)
			data.append(i)

		parent.data = data

	return get_partition_assign(G, get_partitions_tree(root, G))

def temporal_graph_transform(G, F, K=2, alpha=1., order=-1)
	G.index_vertex()
	
	if K == 2:
		return wavelet_cut(G, F, alpha, order)
	else:
		return multi_cut_signal(G, K, F, alpha):
		

def temporal_graph_inverse(G, lambdas, eigvecs):
	k = lambdas.shape[0]
	
	F = lambdas[0] * numpy.ones(G.number_of_nodes())

	for i in range(0, k-1):
		for v in range(G.number_of_nodes()):
			F[v] = F[v] + lambdas[i+1] * eigvecs[v,i]
	
	return F

