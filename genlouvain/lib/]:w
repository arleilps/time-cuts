import networkx
import math
import scipy.optimize
import numpy
import sys
from scipy import sparse

from lib.vis import *
from lib.graph_signal_proc import *
from lib.optimal_cut import *
from scipy import linalg
import matplotlib.pyplot as plt
from IPython.display import Image
from numpy.linalg import eigh

class TimeGraph(object):
	def __init__(self, swp_cost=1., t_max=0):
		self.graphs = [networkx.Graph()]
		self.swp_cost = swp_cost
		self.idx_vertex = []
	
	def index_vertex(self, t, v):
		if len(self.idx_vertex) != self.num_snaps():
			i = 0
			for t in range(len(self.graphs)):
				self.idx_vertex.append({})
				
				for v in self.graphs[0].nodes():
					self.idx_vertex[t][v] = i
					i = i + 1
		
		return self.idx_vertex[t][v]

	def swap_cost(self):
		return self.swp_cost

	def extend(self, t):
		while len(self.graphs) <= t:
			self.graphs.append(networkx.Graph())

			for v in self.graphs[0].nodes():
				self.graphs[-1].add_node(v)
		            
	def add_edge(self, v1,v2,t,w=1.):
		self.extend(t)
		
		if v1 not in self.graphs[0]:
			self.add_node(v1)
						                
		if v2 not in self.graphs[0]:
			self.add_node(v2)
										           
		self.graphs[t].add_edge(v1, v2, weight=w)

	def add_node(self, v):
		for t in range(len(self.graphs)):
			self.graphs[t].add_node(v)

	def add_snap(self, G, t):
		for (v1,v2) in G.edges():
			self.add_edge(v1,v2,t)

	def window(self, tb, te):
		G = TimeGraph()
		for t in range(tb, te+1):
			G.add_snap(self.snap(t), t-tb)

		return G
	
	def size(self):
		return networkx.number_of_nodes(self.graphs[0])
	     
	def num_snaps(self):
		return len(self.graphs)

	def snap(self,t):
		return self.graphs[t]

	def norm_cut(self):
		c = normalized_cut(self.g)
		                    
		return c
	
	def index(self, p):
		#TODO: Can be faster!
		return self.graphs[0].nodes()[p % self.size()], int(p / self.size())

	def index_pos(self, p):
		return p % self.size(), int(p / self.size())

	def set_values(self, f):
		i = 0
		for t in range(len(self.graphs)):
			for v in self.graphs[t].nodes():
				self.graphs[t].node[v]["value"] = f[i]
				i = i + 1

	def get_single_cuts(self, f):
		c = numpy.zeros((self.num_snaps(), self.graphs[0].number_of_nodes()))
		i = 0
		for t in range(len(self.graphs)):
			j = 0
			for v in self.graphs[t].nodes():
				c[t][j] = f[i]
				i = i + 1
				j = j + 1
		return c

	def name_stacked(self, v, t):
		return str(t) + "--" + str(v)
	
	def parse_name_stacked(self, name):
		vec = name.split("--")

		return int(vec[1]), int(vec[0])
	
	def build_stacked_graph(self):
		SG = networkx.Graph()
		
		for t in range(len(self.graphs)):
			for e in self.graphs[t].edges():
				v1 = str(t) + "--" + str(e[0])
				v2 = str(t) + "--" + str(e[1])
				SG.add_edge(v1, v2, weight=self.graphs[t][e[0]][e[1]]["weight"])
		
		for t in range(len(self.graphs)-1):
			for v in self.graphs[0].nodes():
				v1 = str(t) + "--" + str(v)
				v2 = str(t+1) + "--" + str(v)
				
				SG.add_edge(v1, v2, weight=self.swp_cost)

		return SG

def sweep_single_qp(G, x, single_side=False):
	best_val = sys.float_info.max
	sorted_x = numpy.argsort(x)
	size_one = 0
	edges_cut = 0
	nodes_one = {}
	best_edges_cut = 0
	best_size_one = 0

	if single_side:
		start = 1
		end = G.number_of_nodes()-1
		nodes_one[G.nodes()[sorted_x[0]]] = True
		edges_cut = G.degree(G.nodes()[sorted_x[0]], weight="weight")
	else:
		start = 2
		end = G.number_of_nodes()-2
		nodes_one[G.nodes()[sorted_x[0]]] = True
		nodes_one[G.nodes()[sorted_x[1]]] = True
		edges_cut = G.degree(G.nodes()[sorted_x[0]], weight="weight") + G.degree(G.nodes()[sorted_x[1]], weight="weight")

#	print(edges_cut)

	for i in range(start, end):
		size_one = size_one + 1
		
		nodes_one[G.nodes()[sorted_x[i]]] = True
		u = G.nodes()[sorted_x[i]]
		
		for v in G.neighbors(u):
			if v not in nodes_one:
				edges_cut = edges_cut + G[v][u]["weight"]
			else:
				edges_cut = edges_cut - G[v][u]["weight"]

#		print(nodes_one)
#		print(edges_cut)

		den = size_one * (end-start-size_one)

		if den > 0:
			val = float(edges_cut) / den
		else:
			val = networkx.number_of_nodes(G)
		
		if val <= best_val:
			best_cand = i
			best_val = val
			best_edges_cut = edges_cut
			best_size_one = size_one

	vec = []

	vec = numpy.zeros(networkx.number_of_nodes(G))

	for i in range(x.shape[0]):
		if i <= best_cand:
			vec[sorted_x[i]] = -1.
		else:
			vec[sorted_x[i]] = 1.

	return {"cut": vec, "edges": best_edges_cut, "size_one": best_size_one}

def sweep_single(G, x):
	best_val = sys.float_info.max
	sorted_x = numpy.argsort(x)
	size_one = 0
	edges_cut = 0
	nodes_one = {}
	best_edges_cut = 0
	best_size_one = 0

	for i in range(x.shape[0]):
		size_one = size_one + 1
		
		nodes_one[G.nodes()[sorted_x[i]]] = True
		u = G.nodes()[sorted_x[i]]
		
		for v in G.neighbors(u):
			if v not in nodes_one:
				edges_cut = edges_cut + G[v][u]["weight"]
			else:
				edges_cut = edges_cut - G[v][u]["weight"]
			
		den = size_one * (networkx.number_of_nodes(G)-size_one)

		if den > 0:
			val = float(edges_cut) / den
		else:
			val = networkx.number_of_nodes(G)
			
		if val <= best_val:
#			print(edges_cut)
#			print(nodes_one)
			best_cand = i
			best_val = val
			best_edges_cut = edges_cut
			best_size_one = size_one

	vec = []

	vec = numpy.zeros(networkx.number_of_nodes(G))

	for i in range(x.shape[0]):
		if i <= best_cand:
			vec[sorted_x[i]] = -1.
		else:
			vec[sorted_x[i]] = 1.

	return {"cut": vec, "edges": best_edges_cut, "size_one": best_size_one}

def sweep(G, x):
	best_score = sys.float_info.max
	sorted_x = numpy.argsort(x)
	size_one = 0
	edges_cut = 0
	swaps = 0
	nodes_one = []
	sizes_one = []
	den = 0

	for t in range(G.num_snaps()):
		nodes_one.append({})
		sizes_one.append(0)

	for i in range(x.shape[0]):
		(v,t) = G.index(sorted_x[i])
		den = den - sizes_one[t] * (G.size() - sizes_one[t])
		sizes_one[t] = sizes_one[t] + 1
		den = den + sizes_one[t] * (G.size() - sizes_one[t])

		nodes_one[t][v] = True
		
		for u in G.graphs[t].neighbors(v):
			if u not in nodes_one[t]:
				edges_cut = edges_cut + G.graphs[t].edge[v][u]["weight"]
			else:
				edges_cut = edges_cut - G.graphs[t].edge[v][u]["weight"]

		if t+1 < G.num_snaps():
			if v not in nodes_one[t+1]:
				swaps = swaps + G.swap_cost()
			else:
				swaps = swaps - G.swap_cost()

		if t > 0:
			if v not in nodes_one[t-1]:
				swaps = swaps + G.swap_cost()
			else:
				swaps = swaps - G.swap_cost()
		
		if den > 0:
			score = float(edges_cut + swaps) / den
		else:
			score = sys.float_info.max

		if score <= best_score:
			best_score = score
			best = i
			best_edges_cut = edges_cut
			best_swaps = swaps

	vec = numpy.zeros(G.size() * G.num_snaps())

	for i in range(x.shape[0]):
		if i <= best:
			vec[sorted_x[i]] = -1.
		else:
			vec[sorted_x[i]] = 1.

	return {"cut": vec, "score": best_score, "edges": best_edges_cut, "swaps": best_swaps}

def evaluate_cut(G, x):
	edges_cut = 0
	swaps = 0
	den = 0
	
	for t in range(G.num_snaps()):
		for e in G.snap(t).edges():
			v1 = e[0]
			v2 = e[1]

			if x[G.index_vertex(t, v1)] + x[G.index_vertex(t, v2)] == 0:
				edges_cut = edges_cut + G.snap(t)[v1][v2]["weight"]

		print(edges_cut)

	print(G.idx_vertex)
	
	for t in range(G.num_snaps()-1):
		size_one = 0
		for v in G.snap(t).nodes():
			if x[G.index_vertex(t, v)] + x[G.index_vertex(t+1, v)] == 0:
				swaps = swaps + G.swap_cost()
			
			if x[G.index_vertex(t, v)] < 0:
				size_one = size_one + 1

		den = den + size_one * (G.size() - size_one)
	
	return edges_cut, swaps, den

def aggreg_single(G, c):
#	c = []
	edges_cut = 0

#	for i in range(len(x)):
#		c.append(sweep_single(G.snap(i), x[i]))
#		edges_cut = edges_cut + c[i]["edges"]
	
	for i in range(len(c)):
		edges_cut = edges_cut + c[i]["edges"]

	Gs = networkx.Graph()

	Gs = networkx.Graph()
	Gs.add_edge(0, 1, weight=0.)
	Gs.add_edge(0, 2, weight=0.)

	for i in range(1, len(c)):
		w = float(numpy.absolute(c[i-1]["cut"] - c[i]["cut"]).sum()) / 2

		Gs.add_edge(2*i-1, 2*i+1, weight=w)
		Gs.add_edge(2*i, 2*i+2, weight=w)
		
		Gs.add_edge(2*i-1, 2*i+2, weight=(G.size()-w))
		Gs.add_edge(2*i, 2*i+1, weight=(G.size()-w))

	Gs.add_edge(2*len(c)-1, 2*len(c)+1, weight=0.)
	Gs.add_edge(2*len(c), 2*len(c)+1, weight=0.)
	
	p = networkx.shortest_path(Gs, source=0, target=2*len(c)+1, weight="weight")
	vec = numpy.array([])
	swaps = 0
	den = 0

	for i in range(1, len(p)-1):
		if p[i] % 2 == 0:
			c[i-1]["cut"] =  -1 * c[i-1]["cut"]
		
		s1 = 0

		for j in range(c[i-1]["cut"].shape[0]):
			if c[i-1]["cut"][j] < 0:
				s1 = s1 + 1
		
		den = den + s1 * (G.size() - s1)

		swaps = swaps + Gs.edge[p[i-1]][p[i]]["weight"]
		vec = numpy.concatenate((vec, c[i-1]["cut"]), axis=0)

	score = float(edges_cut + swaps) / den
	
	return {"cut": vec, "score": score, "edges": edges_cut, "swaps": swaps}

def create_laplacian_matrix(G):
	"""
		Creates laplacian matrix for temporal graph.
		This is the laplacian of the layered/stacked graph with edges
		connecting the same node within consecutive snapshots
	"""
	row = []
	column = []
	value = []

	for t in range(G.num_snaps()):
		Lg = networkx.laplacian_matrix(G.snap(t))
		for (i,j) in zip(*scipy.nonzero(Lg)):
			row.append(G.size()*t + i)
			column.append(G.size()*t + j)
			
			if i != j:
				value.append(Lg[i,j])
			else:
				if t > 0 and t < G.num_snaps() - 1:
					value.append(Lg[i,j] + 2 * G.swap_cost())
				else:	
					value.append(Lg[i,j] + 1 * G.swap_cost())
	
	for t in range(G.num_snaps()-1):
		for v in range(G.size()):
			row.append(t*G.size() + v)
			column.append((t+1)*G.size() + v)
			value.append(-1 * G.swap_cost())
			
			column.append(t*G.size() + v)
			row.append((t+1)*G.size() + v)
			value.append(-1 * G.swap_cost())


	sz = G.num_snaps() * G.size()
	return scipy.sparse.csr_matrix((value, (row, column)), shape=(sz, sz), dtype=float)


def create_laplacian_matrix_local_single(G, Cb, Ca, swap_cost):
	"""
		Creates laplacian matrix for temporal graph locally.
		This is the laplacian of the layered/stacked graph with edges
		connecting the same node within consecutive snapshots.
		Cuts in the previous and maybe later snapshots becomes supernodes
		to bias the local cut computation.
	"""
	row = []
	column = []
	value = []

	Lg = networkx.laplacian_matrix(G)
	for (i,j) in zip(*scipy.nonzero(Lg)):
		row.append(i)
		column.append(j)
			
		if i != j:
			value.append(Lg[i,j])
		else:
			value.append(Lg[i,j] + 2 * swap_cost)
	
	#adding supernodes
	vb1 = G.number_of_nodes()
	vb2 = G.number_of_nodes()+1
	sz_b1 = 0

	va1 = G.number_of_nodes()+2
	va2 = G.number_of_nodes()+3
	sz_a1 = 0

	#prefix snapshot
	i = 0
	for v in G.nodes():
		if Cb[i] < 0:
			row.append(vb1)
			sz_b1 = sz_b1 + 1
		else:
			row.append(vb2)
			
		column.append(i)
		value.append(-swap_cost)
		
		if Cb[i] < 0:
			column.append(vb1)
		else:
			column.append(vb2)
			
		row.append(i)
		value.append(-swap_cost)
		
		i = i + 1
	
	#suffix snapshot
	i = 0
	for v in G.nodes():
		if Ca[i] < 0:
			row.append(va1)
			sz_a1 = sz_a1 + 1
		else:
			row.append(va2)
			
		column.append(i)
		value.append(-swap_cost)
		
		if Ca[i] < 0:
			column.append(va1)
		else:
			column.append(va2)
			
		row.append(i)
		value.append(-swap_cost)
		
		i = i + 1

	row.append(vb1)
	column.append(vb1)
	value.append(sz_b1 * swap_cost)
	
	row.append(vb2)
	column.append(vb2)
	value.append((G.number_of_nodes() - sz_b1) * swap_cost)

	row.append(va1)
	column.append(va1)
	value.append(sz_a1 * swap_cost)
	
	row.append(va2)
	column.append(va2)
	value.append((G.number_of_nodes() - sz_a1) * swap_cost)

	sz = G.number_of_nodes() + 4
	
	return scipy.sparse.csr_matrix((value, (row, column)), shape=(sz, sz), dtype=float)

def create_laplacian_matrix_local(G, Cb, Ca):
	"""
		Creates laplacian matrix for temporal graph locally.
		This is the laplacian of the layered/stacked graph with edges
		connecting the same node within consecutive snapshots.
		Cuts in the previous and maybe later snapshots becomes supernodes
		to bias the local cut computation.
	"""
	row = []
	column = []
	value = []

	#Standard temporal graph
	for t in range(G.num_snaps()):
		Lg = networkx.laplacian_matrix(G.snap(t))
		for (i,j) in zip(*scipy.nonzero(Lg)):
			row.append(G.size()*t + i)
			column.append(G.size()*t + j)
			
			if i != j:
				value.append(Lg[i,j])
			else:
				value.append(Lg[i,j] + 2 * G.swap_cost())
	
	for t in range(G.num_snaps()-1):
		for v in range(G.size()):
			row.append(t*G.size() + v)
			column.append((t+1)*G.size() + v)
			value.append(-1 * G.swap_cost())
			
			column.append(t*G.size() + v)
			row.append((t+1)*G.size() + v)
			value.append(-1 * G.swap_cost())
	
	#adding supernodes
	vb1 = G.size()*G.num_snaps()
	vb2 = G.size()*G.num_snaps()+1
	sz_b1 = 0

	va1 = G.size()*G.num_snaps()+2
	va2 = G.size()*G.num_snaps()+3
	sz_a1 = 0

	#prefix snapshot
	i = 0
	for v in G.snap(0).nodes():
		if Cb[i] < 0:
			row.append(vb1)
			sz_b1 = sz_b1 + 1
		else:
			row.append(vb2)
			
		column.append(i)
		value.append(-G.swap_cost())
		
		if Cb[i] < 0:
			column.append(vb1)
		else:
			column.append(vb2)
			
		row.append(i)
		value.append(-G.swap_cost())
		
		i = i + 1
	
	#suffix snapshot
	i = 0
	for v in G.snap(0).nodes():
		if Ca[i] < 0:
			row.append(va1)
			sz_a1 = sz_a1 + 1
		else:
			row.append(va2)
			
		column.append(i)
		value.append(-G.swap_cost())
		
		if Ca[i] < 0:
			column.append(va1)
		else:
			column.append(va2)
			
		row.append(i)
		value.append(-G.swap_cost())
		
		i = i + 1

	row.append(vb1)
	column.append(vb1)
	value.append(sz_b1 * G.swap_cost())
	
	row.append(vb2)
	column.append(vb2)
	value.append((G.size() - sz_b1) * G.swap_cost())

	row.append(va1)
	column.append(va1)
	value.append(sz_a1 * G.swap_cost())
	
	row.append(va2)
	column.append(va2)
	value.append((G.size() - sz_a1) * G.swap_cost())

	sz = G.num_snaps() * G.size() + 4
	
	return scipy.sparse.csr_matrix((value, (row, column)), shape=(sz, sz), dtype=float)

def create_constraint_matrix(n, vb1, vb2, va1=0, va2=0):
	"""
		Creating constraint matrix C. values should add to 0. and 
		in particular super-node values should add to 0. to distinguish
		two sides of the prefix and suffix cut.
	"""
	row = []
	column = []
	value = []

	for i in range(n):
		row.append(0)
		column.append(i)
		value.append(1.)

	row.append(1)
	column.append(vb1)
	value.append(1.)

	row.append(1)
	column.append(vb2)
	value.append(1.)
	
	if va1 != 0 and va2 != 0:
		row.append(2)
		column.append(va1)
		value.append(1.)

		row.append(2)
		column.append(va2)
		value.append(1.)
	
		return scipy.sparse.csr_matrix((value, (row, column)), shape=(3, n), dtype=float)
	else:
		return scipy.sparse.csr_matrix((value, (row, column)), shape=(2, n), dtype=float)

def create_c_matrix(G):
	row = []
	column = []
	value = []
	
	for t in range(G.num_snaps()):
		for i in range(G.size()):
			for j in range(G.size()):
				row.append(t*G.size() + i)
				column.append(t*G.size() + j)
				
				if i == j:
					value.append(G.size()-1)
				else:
					value.append(-1.)
	
	sz = G.num_snaps() * G.size()
	
	return scipy.sparse.csr_matrix((value, (row, column)), shape=(sz, sz), dtype=float)

def eigen_vec_cut_prod(G):
	L = create_laplacian_matrix(G)
	C = create_c_matrix(G)
	
	M = scipy.sparse.csr_matrix.dot(scipy.sparse.csr_matrix.dot(C, L), C)
	(eigvals, eigvecs) = scipy.sparse.linalg.eigs(M, k=G.num_snaps()+1, which='SM')
	x = scipy.sparse.csr_matrix.dot(eigvecs[:,0], C)
	
	return sweep(G, x.real)

def eigen_vec_cut_inv(G):
	L = create_laplacian_matrix(G).todense()
	C = create_c_matrix(G).todense()
	sqrtC = sqrtm(C)
	isqrtC = sqrtm(scipy.linalg.pinv(C))
	M = numpy.dot(numpy.dot(isqrtC, L), isqrtC)
	(eigvals, eigvecs) = scipy.linalg.eigh(M, eigvals=(G.num_snaps(), G.num_snaps()))

	x = numpy.asarray(numpy.dot(eigvecs[:,0], sqrtC))[0]
	
	return sweep(G, x.real)

def power_method(mat, maxit):
	vec = numpy.ones(mat.shape[0])
	vec = vec/numpy.linalg.norm(vec)

	for i in range(maxit):
		vec = scipy.sparse.csr_matrix.dot(vec, mat)
		vec = vec/numpy.linalg.norm(vec)
 
	return numpy.asarray(vec)

def fast_eigen_vec_cut(G,niter=0):
	L = create_laplacian_matrix(G)
	C = create_c_matrix(G)
	
	M = C-L

	if niter == 0:
		(eigvals, eigvecs) = scipy.sparse.linalg.eigs(M, k=1, which='LM')
		x = scipy.sparse.csr_matrix.dot(eigvecs[:,0], C)
	else:
		x = power_method(M, niter)
		x = scipy.sparse.csr_matrix.dot(x, C)
	
	return sweep(G, x.real)

def single_graph(G):
	cs = []
	for t in range(G.num_snaps()):
		Lg = networkx.laplacian_matrix(G.snap(t))
		
		try:
			(eigvals, eigvecs) = scipy.sparse.linalg.eigs(Lg, k=2, which='SM')
		except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
			Ld = Lg.todense()
			(eigvals, eigvecs) = scipy.linalg.eigh(Ld, eigvals=(0, 1))
		
		x  = eigvecs[:,numpy.argsort(eigvals)[1]].real
		c = sweep_single(G.snap(t), x)
		cs.append(c)
	
	return aggreg_single(G, cs)

def union_graph(G):
	"""
		Computes best cut for the union graph (smashing all the snapshots into a single graph)
	"""
	Gu = networkx.Graph()
	
	for v in G.snap(0).nodes():
		Gu.add_node(v)

	for t in range(G.num_snaps()):
		Gs = G.snap(t)
		for e in Gs.edges():
			if Gu.has_edge(e[0],e[1]):
				Gu.edge[e[0]][e[1]]["weight"] = Gu.edge[e[0]][e[1]]["weight"] + Gs.edge[e[0]][e[1]]["weight"]
			else:
				Gu.add_edge(e[0],e[1],weight=Gs.edge[e[0]][e[1]]["weight"])

	Lg = networkx.laplacian_matrix(Gu)
	
	try:
		#Sometimes fails with an arpack error
		(eigvals, eigvecs) = scipy.sparse.linalg.eigs(Lg, k=2, which='SM')
	except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
		Ld = Lg.todense()
		(eigvals, eigvecs) = scipy.linalg.eigh(Ld, eigvals=(0, 1))
	
	x = numpy.asarray(eigvecs[:,numpy.argsort(eigvals)[1]].real)
	
	c = sweep_single(Gu, x)
	
	C = numpy.array([])

	for t in range(G.num_snaps()):
		C = numpy.concatenate((C, c["cut"]), axis=0)

	c["swaps"] = 0
	c["score"] = float(c["edges"]) / (c["size_one"] * (G.size()-c["size_one"]))
	c["cut"] = C
	
	return c

def iterative_cont(G, niter):
	c = []
	for t in range(G.num_snaps()):
		Lg = networkx.laplacian_matrix(G.snap(t))
		
		try:
			(eigvals, eigvecs) = scipy.sparse.linalg.eigs(Lg, k=2, which='SM')
		except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
			Ld = Lg.todense()
			(eigvals, eigvecs) = scipy.linalg.eigh(Ld, eigvals=(0, 1))
		
		x  = eigvecs[:,numpy.argsort(eigvals)[1]].real
		c.append(x)

	c = numpy.array(c)

	for i in range(niter):
		for t in range(G.num_snaps()):
			if t > 0 and t < G.num_snaps()-1:
				if numpy.dot(c[t-1], c[t+1]) > numpy.dot(c[t-1], -c[t+1]):
					b = (c[t-1] + c[t+1])
				else:
					b = (c[t-1] - c[t+1])
			elif t > 0:
				b = c[t-1]
			else:
				b = c[t+1]

			c[t] = local_single_qp_cont(G.snap(t), b)
			c[t] = c[t] / numpy.linalg.norm(c[t])	
	
	SG = G.build_stacked_graph()
	
	index = {}
	i = 0
	for sv in SG.nodes():
		v,t = G.parse_name_stacked(sv)

		if t not in index:
			index[t] = {}

		index[t][v] = i
		i = i + 1

	x = numpy.zeros(SG.number_of_nodes())
	
	for t in range(G.num_snaps()):
		i = 0
		for v in G.snap(0).nodes():
			x[index[t][v]] = c[t][i]
			i = i + 1
	
	sc = sweep_single(SG, numpy.array(x))

	c = numpy.zeros(G.num_snaps() * G.size())

	for t in range(G.num_snaps()):
		i = 0
		for v in G.snap(0).nodes():
			c[t*G.size()+i] = sc["cut"][index[t][v]]
			i = i + 1

	edges, swaps, den = evaluate_cut(G, c)
	
	score = float(edges + swaps) / den

	return {"cut" : c, "score" : score, "edges:" : edges, "swaps:" : swaps}

def iterative(G, niter):
	cs = single_graph(G)
	c = numpy.zeros((G.num_snaps(), G.size()))
	
	for i in range(cs["cut"].shape[0]):
		v, t = G.index_pos(i)
		c[t,v] = cs["cut"][i]
	
	for i in range(niter):
		ncs = []
		for t in range(G.num_snaps()):
			if t > 0 and t < G.num_snaps()-1:
				nc = local_single_qp(G, c[t-1], c[t+1], t)
			elif t > 0:
				nc = local_single_qp(G, c[t-1], None, t)
			else:
				nc = local_single_qp(G, c[t+1], None, t)
			c[t] = nc["cut"]
			ncs.append(nc)

	
	return aggreg_single(G, ncs)

def local_single_qp_cont(G, b):
	L = networkx.laplacian_matrix(G)
	M1 = scipy.sparse.block_diag((L, L))
	M2 = scipy.sparse.block_diag((scipy.sparse.identity(G.number_of_nodes()), scipy.sparse.csr_matrix(scipy.asmatrix(scipy.outer(b, b)))), format='csr')
	M2.indices = -M2.indices + M2.shape[1] - 1
	M = M1 + M2
	
	try:
		(eigvals, eigvecs) = scipy.sparse.linalg.eigs(M, k=1, which='SM')
	except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
		Md = M.todense()
		(eigvals, eigvecs) = scipy.linalg.eigh(Md, eigvals=(0, 0))
		
	lamb = eigvals[0]

	return numpy.dot(scipy.linalg.inv((L-lamb*scipy.sparse.identity(G.number_of_nodes())).todense()), b)


def local_single_qp(G, Cb, Ca, t, c_past=None):
	Gl = G.snap(t).copy()
	
	i = 0
	for v in G.snap(t).nodes():
		if Cb[i] < 0:
			Gl.add_edge(v,'vb1', weight=G.swap_cost())
		else:
			Gl.add_edge(v,'vb2', weight=G.swap_cost())
		i = i + 1
	
	if Ca is not None:
		i = 0
		for v in G.snap(t).nodes():
			if Ca[i] < 0:
				Gl.add_edge(v,'va1', weight=G.swap_cost())
			else:
				Gl.add_edge(v,'va2', weight=G.swap_cost())
			i = i + 1
	
	vb1 = Gl.nodes().index('vb1')
	vb2 = Gl.nodes().index('vb2')

	if Ca is None:
		C = create_constraint_matrix(Gl.number_of_nodes(), vb1, vb2)
	else:
		va1 = Gl.nodes().index('va1')
		va2 = Gl.nodes().index('va2')
	
		C = create_constraint_matrix(Gl.number_of_nodes(), vb1, vb2, va1, va2)
	
	Q, R = scipy.linalg.qr(C.transpose().todense(), mode='full', pivoting=False)

	L = networkx.laplacian_matrix(Gl)
	
	sQ = scipy.sparse.csr_matrix(Q)
	
	QLQ = scipy.sparse.csr_matrix.dot(scipy.sparse.csr_matrix.dot(sQ.transpose(), L), sQ)

	if Ca is not None:
		G22 = QLQ[3:, 3:]
	else:
		G22 = QLQ[2:, 2:]
	
	try:
		(eigvals, eigvecs) = scipy.sparse.linalg.eigs(G22, k=1, which='SM') 
	except (scipy.sparse.linalg.ArpackNoConvergence, scipy.sparse.linalg.ArpackError) as excpt:
		G22D = G22.todense()
		(eigvals, eigvecs) = scipy.linalg.eigh(G22D, eigvals=(0, 1))
	
	z = eigvecs[:,0]
	
	if Ca is None:
		x = scipy.sparse.csr_matrix.dot(sQ, numpy.concatenate((numpy.zeros(2), z)))
		if x[vb1] < 0:
			x[vb1] = -sys.float_info.max
			x[vb2] = sys.float_info.max
		else:
			x[vb1] = sys.float_info.max
			x[vb2] = -sys.float_info.max
			
	else:
		x = scipy.dot(Q, numpy.concatenate((numpy.zeros(3), z)))
		if x[vb1] < 0:
			x[vb1] = -sys.float_info.max
			x[vb2] = sys.float_info.max
		else:
			x[vb1] = sys.float_info.max
			x[vb2] = -sys.float_info.max
		
		if x[va1] < 0:
			x[va1] = -sys.float_info.max
			x[va2] = sys.float_info.max
		else:
			x[va1] = sys.float_info.max
			x[va2] = -sys.float_info.max

	if Ca is None:
		c = sweep_single_qp(Gl, x.real, True)
	else:
		c = sweep_single_qp(Gl, x.real, False)

	cut = []
	for v in G.snap(t).nodes():
		cut.append(c["cut"][Gl.nodes().index(v)])

	c["cut"] = numpy.array(cut)

	return c

